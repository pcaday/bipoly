# Birational polynomial simplification with simulated annealing

This code implements a simulated annealing-based algorithm which searches for birationally equivalent but simpler models for plane algebraic curves.

## Compiling

The body of the code is all in one file, bipoly.c, and does not require any external libraries (except for arbitrary precision mode). It's designed to allow the polynomial coefficients to have a user-configurable data type for the coefficients, which is specified by a #define:

* `CT_long`: 	long int										(fast but only useful for small polynomials and coefficients)

* `CT_ll`: 		long long									(also fast, but only useful for small polynomials and coefficients)

* `CT_mshort`:	unsigned short, arithmetic modulo (2^16 - 15)	(what I usually used if I remember right)

* `CT_mlong`:	unsigned long, arithmetic modulo (2^32 - 5)

* `CT_gmp`:	arbitrary size integer coefficients -- compile with C++ and [GMPXX](http://www.gmplib.org/)
					(this is quite slow, but useful for checking the modular arithmetic computations and computing the final coefficients)

## Basic Usage

Without arguments, `bipoly` outputs a short help message with a list of commands. The basic call is

	bipoly cmd [args...]

To simplify a small polynomial, you can give it on the command line (in quotes), and use the `samr` command (short for "simulated annealing with maximum radius"):

	bipoly samr '3*x^3*y^2 - x*y + 2x - y + 3'

Larger polynomials you'll probably want to load from a file, and use the command `saiter`, which runs several rounds of the algorithm:

	bipoly saiter -I poly_file

Diagnostic information is printed to stdout. You can save the optimized polynomial in a file with `-O`:

	bipoly saiter -I poly_file -O opt_poly_file

The map it finds is listed in stdout as a "move sequence" of basic operations which are listed by number (in the range 1-8). At present, there is (unfortunately) no command to output the move sequence generated by the algorithm to a specified file, but you can grep/sed it from stdout.

You can convert this move sequence to a birational map using the `convmap` command:

	bipoly convmap -MI move_sequence_file xy

Here the 'xy' (or some other polynomial) is required so bipoly knows the variable names.


## Parameters and Notes

The algorithm bipoly uses is based on simulated annealing, so it's randomized and different runs will give different results. You can ask it to remember previous solutions and avoid them later (which it calls avoidlists) using the `-AI` and `-AO` arguments.

To simplify a polynomial, it tries applying operations from a small fixed set of simple birational transformations (add, sub, flip, and sep -- described in the usage message). In decreasing order of importance, it's attempting to reduce the degree of the polynomial in each variable, the total degree, the number of terms, the sum of coefficients' absolute value, and maximum coefficient size (the latter two ignored for modular arithmetic of course!).

There are a lot of parameters to the simulated annealing algorithm, and you can try twiddling them. In particular:

* Initial temperature (`-T`): adjusts how willing the algorithm is to accept unpromising routes at first  
* Weight function (`-w`): the weight function controls what the optimizer considers "good" when optimizing the polynomial. You can examine the existing weight functions in `bipoly_cost`/`bipoly_cost_diff` as well as create new ones.

Also, a note when using the modular arithmetic computations: the optimizer tries to eliminate high-order polynomial terms, and there's a low but nonzero probability it might have made these terms only zero modulo the base rather than truly zero. I've never seen this happen, but it's probably good to check using the arbitrary precision (GMP) code.

## More Information

You can read more about the algorithm in this [poster](http://ants9.loria.fr/slides/poster_caday.pdf), from the ANTS IX conference (2009). 
